<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Image Editor with Dynamic Text Style Controls</title>
<style>
  body {
    font-family: Arial, sans-serif;
    padding: 10px;
    -webkit-user-select: text;
    -webkit-touch-callout: default;
  }
  #container {
    position: relative;
    border: 1px solid #ccc;
    display: inline-block;
    overflow: auto;
    background: #f0f0f0;
    width: 100%;
    max-width: 900px;
    max-height: 80vh;
    box-sizing: border-box;
  }
  #zoomable-content {
    position: relative;
    user-select: none;
  }
  #zoomable-content img {
    display: block;
    user-select: none;
    -webkit-user-drag: none;
    max-width: 100%;
    height: auto;
  }
  .textbox-wrapper {
    position: absolute;
    display: inline-block;
  }
  .textbox-wrapper textarea {
    font-size: 16px;
    padding: 4px;
    border: 1px dashed #666;
    background: rgba(255,255,255,0.7);
    resize: both;
    width: 200px;
    height: 60px;
    box-sizing: border-box;
    user-select: text;
    cursor: text;
    overflow-wrap: break-word;
    font-weight: normal;
    font-style: normal;
  }
  .drag-handle {
    position: absolute;
    top: -10px;
    left: -10px;
    width: 24px;
    height: 24px;
    background-color: #007bff;
    border-radius: 50%;
    cursor: grab;
    z-index: 1000;
    touch-action: none;
  }
  .drag-handle:active {
    cursor: grabbing;
  }
  #controls {
    margin-top: 15px;
  }
  button {
    margin-right: 10px;
    padding: 6px 12px;
    font-size: 14px;
  }
  #styleControls {
    position: absolute;
    display: flex;
    gap: 8px;
    background: rgba(255,255,255,0.9);
    border: 1px solid #ccc;
    border-radius: 4px;
    padding: 4px 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    user-select: none;
    z-index: 2000;
    visibility: hidden;
    transition: visibility 0.2s, opacity 0.2s;
    opacity: 0;
  }
  #styleControls.visible {
    visibility: visible;
    opacity: 1;
  }
  #styleControls button, #styleControls select {
    cursor: pointer;
    font-size: 14px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 3px;
    padding: 4px 8px;
  }
  #styleControls button.active {
    background-color: #007bff;
    color: white;
  }
  #styleControls select {
    min-width: 60px;
  }
</style>
</head>
<body>

<h2>Image Editor with Dynamic Text Style Controls</h2>

<input type="file" id="imageUploader" accept="image/*" />
<div id="container">
  <div id="zoomable-content"></div>
</div>

<div id="controls" style="display:none;">
  <button id="addTextBoxBtn">Add Text Box</button>
  <button id="downloadBtn">Download Image</button>
  <span style="margin-left:20px;">Use your deviceâ€™s native zoom controls (pinch zoom, browser zoom). Drag blue dot to move boxes.</span>
</div>

<!-- Floating style toolbar -->
<div id="styleControls">
  <button id="boldBtn" title="Toggle Bold"><b>B</b></button>
  <button id="italicBtn" title="Toggle Italic"><i>I</i></button>
  <select id="fontSizeSelect" title="Select Text Size">
    <option value="12px">12</option>
    <option value="14px">14</option>
    <option value="16px" selected>16</option>
    <option value="18px">18</option>
    <option value="20px">20</option>
    <option value="24px">24</option>
    <option value="28px">28</option>
    <option value="32px">32</option>
  </select>
</div>

<script>
  const imageUploader = document.getElementById('imageUploader');
  const container = document.getElementById('container');
  const zoomableContent = document.getElementById('zoomable-content');
  const controls = document.getElementById('controls');
  const addTextBoxBtn = document.getElementById('addTextBoxBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  const styleControls = document.getElementById('styleControls');
  const boldBtn = document.getElementById('boldBtn');
  const italicBtn = document.getElementById('italicBtn');
  const fontSizeSelect = document.getElementById('fontSizeSelect');

  let imageElement = null;
  let focusedTextarea = null;

  // Show/hide styleControls and position above focused textarea
  function updateStyleControlsPosition() {
    if (!focusedTextarea) {
      styleControls.classList.remove('visible');
      return;
    }
    const wrapper = focusedTextarea.parentElement;
    const containerRect = container.getBoundingClientRect();
    const textareaRect = focusedTextarea.getBoundingClientRect();

    // Calculate position relative to container scroll and edges
    const top = textareaRect.top - containerRect.top + container.scrollTop;
    const left = textareaRect.left - containerRect.left + container.scrollLeft;

    // Position the controls slightly above and slightly left aligned with textarea
    const controlsHeight = styleControls.offsetHeight;
    const controlsWidth = styleControls.offsetWidth;

    let posTop = top - controlsHeight - 8; // 8px margin
    let posLeft = left;

    // Prevent going off top of container
    if (posTop < container.scrollTop) posTop = top + focusedTextarea.offsetHeight + 8;

    // Prevent going off left/right of container
    if (posLeft + controlsWidth > container.scrollLeft + container.clientWidth) {
      posLeft = container.scrollLeft + container.clientWidth - controlsWidth - 8;
    }
    if (posLeft < container.scrollLeft) posLeft = container.scrollLeft + 8;

    // Apply position in px and make visible
    styleControls.style.top = posTop + 'px';
    styleControls.style.left = posLeft + 'px';
    styleControls.classList.add('visible');

    // Update buttons active states
    boldBtn.classList.toggle('active', focusedTextarea.style.fontWeight === 'bold');
    italicBtn.classList.toggle('active', focusedTextarea.style.fontStyle === 'italic');

    // Update font size select value or fallback to 16px
    fontSizeSelect.value = focusedTextarea.style.fontSize || '16px';
  }

  // Hide the style controls
  function hideStyleControls() {
    styleControls.classList.remove('visible');
  }

  // Update textarea style for bold
  boldBtn.addEventListener('click', () => {
    if (!focusedTextarea) return;
    if (focusedTextarea.style.fontWeight === 'bold') {
      focusedTextarea.style.fontWeight = 'normal';
    } else {
      focusedTextarea.style.fontWeight = 'bold';
    }
    updateStyleControlsPosition();
    focusedTextarea.focus();
  });

  // Update textarea style for italic
  italicBtn.addEventListener('click', () => {
    if (!focusedTextarea) return;
    if (focusedTextarea.style.fontStyle === 'italic') {
      focusedTextarea.style.fontStyle = 'normal';
    } else {
      focusedTextarea.style.fontStyle = 'italic';
    }
    updateStyleControlsPosition();
    focusedTextarea.focus();
  });

  // Update textarea font size
  fontSizeSelect.addEventListener('change', () => {
    if (!focusedTextarea) return;
    focusedTextarea.style.fontSize = fontSizeSelect.value;
    updateStyleControlsPosition();
    focusedTextarea.focus();
  });

  // Track focusin/focusout on textareas inside zoomable content
  zoomableContent.addEventListener('focusin', e => {
    if (e.target.tagName === 'TEXTAREA') {
      focusedTextarea = e.target;
      updateStyleControlsPosition();
      // Attach scroll listener on container to reposition controls on scroll
      container.addEventListener('scroll', updateStyleControlsPosition);
    }
  });

  zoomableContent.addEventListener('focusout', e => {
    if (e.target === focusedTextarea) {
      focusedTextarea = null;
      hideStyleControls();
      container.removeEventListener('scroll', updateStyleControlsPosition);
    }
  });

  // On window resize also reposition controls if visible
  window.addEventListener('resize', () => {
    if (focusedTextarea) updateStyleControlsPosition();
  });

  // Image upload handler
  imageUploader.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = event => {
      zoomableContent.innerHTML = '';
      imageElement = new Image();
      imageElement.src = event.target.result;
      imageElement.draggable = false;
      imageElement.style.userSelect = 'none';
      imageElement.style.position = 'relative';
      imageElement.style.maxWidth = '100%';
      imageElement.style.height = 'auto';

      imageElement.onload = () => {
        zoomableContent.appendChild(imageElement);
        controls.style.display = 'block';
        container.scrollTop = 0;
        container.scrollLeft = 0;
      };
    };
    reader.readAsDataURL(file);
  });

  // Add text box
  addTextBoxBtn.addEventListener('click', () => {
    if (!imageElement) return;

    const wrapper = document.createElement('div');
    wrapper.className = 'textbox-wrapper';
    wrapper.style.top = '10px';
    wrapper.style.left = '10px';

    const textarea = document.createElement('textarea');
    textarea.rows = 3;
    textarea.value = 'Edit text';
    wrapper.appendChild(textarea);

    const dragHandle = document.createElement('div');
    dragHandle.className = 'drag-handle';
    wrapper.appendChild(dragHandle);

    zoomableContent.appendChild(wrapper);
    textarea.focus();

    makeDraggable(wrapper, dragHandle);
  });

  // Drag implementation on handle for mouse/touch/pointer
  function makeDraggable(wrapper, handle) {
    let isDragging = false;
    let startX, startY;
    let origX, origY;

    function getPointerPos(e) {
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.clientX !== undefined && e.clientY !== undefined) {
        return { x: e.clientX, y: e.clientY };
      }
      return null;
    }

    function dragStart(e) {
      e.preventDefault();
      const pointer = getPointerPos(e);
      if (!pointer) return;
      isDragging = true;
      startX = pointer.x;
      startY = pointer.y;
      const rect = wrapper.getBoundingClientRect();
      origX = rect.left;
      origY = rect.top;
      handle.style.cursor = 'grabbing';
    }

    function dragMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      const pointer = getPointerPos(e);
      if (!pointer) return;

      const dx = pointer.x - startX;
      const dy = pointer.y - startY;

      const containerRect = zoomableContent.getBoundingClientRect();

      let newLeft = origX + dx - containerRect.left;
      let newTop = origY + dy - containerRect.top;

      newLeft = Math.max(0, Math.min(newLeft, containerRect.width - wrapper.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, containerRect.height - wrapper.offsetHeight));

      wrapper.style.left = newLeft + 'px';
      wrapper.style.top = newTop + 'px';

      // If focused textarea is this one, reposition controls to follow box movement
      if (focusedTextarea && focusedTextarea.parentElement === wrapper) {
        updateStyleControlsPosition();
      }
    }

    function dragEnd(e) {
      if (!isDragging) return;
      isDragging = false;
      handle.style.cursor = 'grab';
    }

    if (window.PointerEvent) {
      handle.style.touchAction = 'none';
      handle.addEventListener('pointerdown', dragStart);
      window.addEventListener('pointermove', dragMove);
      window.addEventListener('pointerup', dragEnd);
      window.addEventListener('pointercancel', dragEnd);
    } else {
      handle.addEventListener('mousedown', dragStart);
      handle.addEventListener('touchstart', dragStart, { passive: false });
      window.addEventListener('mousemove', dragMove);
      window.addEventListener('touchmove', dragMove, { passive: false });
      window.addEventListener('mouseup', dragEnd);
      window.addEventListener('touchend', dragEnd);
      window.addEventListener('touchcancel', dragEnd);
    }
  }

  // Download final image with styled text boxes
  downloadBtn.addEventListener('click', () => {
    if (!imageElement) {
      alert("Please upload an image first.");
      return;
    }

    const canvas = document.createElement('canvas');
    canvas.width = imageElement.naturalWidth;
    canvas.height = imageElement.naturalHeight;
    const ctx = canvas.getContext('2d');

    ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);

    const imageRect = imageElement.getBoundingClientRect();
    const zoomableRect = zoomableContent.getBoundingClientRect();

    const scaleX = canvas.width / imageRect.width;
    const scaleY = canvas.height / imageRect.height;

    const wrappers = zoomableContent.querySelectorAll('.textbox-wrapper');
    wrappers.forEach(wrapper => {
      const textarea = wrapper.querySelector('textarea');
      const style = window.getComputedStyle(textarea);

      const fontSize = parseInt(style.fontSize);
      const fontFamily = style.fontFamily;
      const fontWeight = style.fontWeight;
      const fontStyle = style.fontStyle;
      const color = style.color || 'black';

      const wrapperLeft = parseFloat(wrapper.style.left || 0);
      const wrapperTop = parseFloat(wrapper.style.top || 0);

      const offsetX = wrapperLeft + (zoomableRect.left - imageRect.left);
      const offsetY = wrapperTop + (zoomableRect.top - imageRect.top);

      const x = offsetX * scaleX;
      const y = offsetY * scaleY;

      ctx.fillStyle = color;
      ctx.font = `${fontStyle} ${fontWeight} ${fontSize * scaleX}px ${fontFamily}`;
      ctx.textBaseline = 'top';

      const lines = textarea.value.split('\n');
      const lineHeight = fontSize * 1.2 * scaleY;

      lines.forEach((line, i) => {
        ctx.fillText(line, x, y + i * lineHeight);
      });
    });

  const link = document.createElement('a');
  link.download = 'edited-image.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
  });
</script>

<p><small>Drag the <b>blue dot</b> to move text boxes. Resize boxes using the corner handle. Click inside a box to edit text and see style controls above it (bold, italic, text size). Use your deviceâ€™s native zoom. Text editing works normally.</small></p>

</body>
</html>
