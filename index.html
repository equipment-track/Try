<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Zoomable & Draggable Image Template Editor</title>
<style>
  body {
    font-family: Arial, sans-serif;
    padding: 10px;
    user-select: none;
  }
  #container {
    position: relative;
    border: 1px solid #ccc;
    display: inline-block;
    overflow: hidden;
    touch-action: none;
    background: #f0f0f0;
    cursor: grab;
    width: 600px;
    height: 400px;
  }
  #zoomable-content {
    position: relative;
    transform-origin: 0 0;
    user-select: none;
  }
  #zoomable-content img {
    display: block;
    user-select: none;
    -webkit-user-drag: none;
    max-width: none; /* prevents auto-scaling */
  }
  .textbox {
    position: absolute;
    min-width: 100px;
    min-height: 30px;
    border: 1px dashed #666;
    background: rgba(255,255,255,0.7);
    resize: none;
    font-size: 16px;
    padding: 4px;
    box-sizing: border-box;
    cursor: move;
    user-select: text;
    overflow-wrap: break-word;
  }
  #controls {
    margin-top: 15px;
  }
  button {
    margin-right: 10px;
    padding: 6px 12px;
    font-size: 14px;
  }
</style>
</head>
<body>

<h2>Zoomable and Draggable Image Template Editor</h2>

<input type="file" id="imageUploader" accept="image/*" />
<div id="container">
  <div id="zoomable-content"></div>
</div>

<div id="controls" style="display:none;">
  <button id="addTextBoxBtn">Add Text Box</button>
  <button id="downloadBtn">Download Image</button>
  <span style="margin-left:20px;">Use mouse wheel to zoom (desktop). Pinch to zoom (mobile). Hold Shift and drag box to move (desktop).</span>
</div>

<script>
  const imageUploader = document.getElementById('imageUploader');
  const container = document.getElementById('container');
  const zoomableContent = document.getElementById('zoomable-content');
  const controls = document.getElementById('controls');
  const addTextBoxBtn = document.getElementById('addTextBoxBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  let imageElement = null;

  let scale = 1;
  let lastTouchDistance = null;

  // State for panning the whole image
  let isPanning = false;
  let panStart = { x: 0, y: 0 };
  let panOffset = { x: 0, y: 0 };

  // Load image and setup container and zoomable content size
  imageUploader.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      zoomableContent.innerHTML = '';
      imageElement = new Image();
      imageElement.src = event.target.result;
      imageElement.draggable = false;
      imageElement.style.userSelect = 'none';
      imageElement.style.position = 'relative';

      imageElement.onload = () => {
        zoomableContent.style.width = imageElement.naturalWidth + 'px';
        zoomableContent.style.height = imageElement.naturalHeight + 'px';

        scale = 1;
        panOffset = { x: 0, y: 0 };
        applyTransform(panOffset.x, panOffset.y, scale);

        zoomableContent.appendChild(imageElement);
        controls.style.display = 'block';
      };
    };
    reader.readAsDataURL(file);
  });

  // Add draggable text box
  addTextBoxBtn.addEventListener('click', () => {
    if (!imageElement) return;

    const textbox = document.createElement('textarea');
    textbox.className = 'textbox';
    textbox.style.top = '10px';
    textbox.style.left = '10px';
    textbox.value = 'Edit text';
    textbox.rows = 1;

    makeDraggable(textbox);
    zoomableContent.appendChild(textbox);
    textbox.focus();
  });

  // Make a text box draggable with respect to zoom scale
  function makeDraggable(el) {
    let isDragging = false;
    let startX, startY; // pointer start coords
    let origX, origY;   // element position start

    function getPointerPos(e) {
      if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
      return { x: e.clientX, y: e.clientY };
    }

    function dragStart(e) {
      // On desktop require Shift key to drag text boxes (avoid conflict with text selection)
      if (e.type === 'mousedown' && !e.shiftKey) return;
      e.preventDefault();
      const pointer = getPointerPos(e);
      isDragging = true;
      startX = pointer.x;
      startY = pointer.y;
      const rect = el.getBoundingClientRect();
      origX = rect.left;
      origY = rect.top;
      el.style.cursor = 'grabbing';
      el.focus();
    }

    function dragMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      const pointer = getPointerPos(e);
      const dx = pointer.x - startX;
      const dy = pointer.y - startY;

      let newLeft = (origX + dx - zoomableContent.getBoundingClientRect().left) / scale;
      let newTop = (origY + dy - zoomableContent.getBoundingClientRect().top) / scale;

      newLeft = Math.max(0, Math.min(newLeft, zoomableContent.clientWidth - el.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, zoomableContent.clientHeight - el.offsetHeight));

      el.style.left = newLeft + 'px';
      el.style.top = newTop + 'px';
    }

    function dragEnd(e) {
      if (!isDragging) return;
      isDragging = false;
      el.style.cursor = 'move';
    }

    el.addEventListener('mousedown', dragStart);
    el.addEventListener('touchstart', dragStart, { passive: false });

    document.addEventListener('mousemove', dragMove);
    document.addEventListener('touchmove', dragMove, { passive: false });

    document.addEventListener('mouseup', dragEnd);
    document.addEventListener('touchend', dragEnd);
  }

  // Apply transform for pan and zoom
  function applyTransform(panX, panY, scale) {
    zoomableContent.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  }

  // Mouse wheel zoom on container, centered on cursor position
  container.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = zoomableContent.getBoundingClientRect();

    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const zoomFactor = 0.1;
    let newScale = scale;
    if (e.deltaY < 0) {
      newScale = scale * (1 + zoomFactor);
    } else {
      newScale = scale * (1 - zoomFactor);
    }
    newScale = Math.min(Math.max(newScale, 0.2), 5);

    panOffset.x -= (mouseX / scale) * (newScale - scale);
    panOffset.y -= (mouseY / scale) * (newScale - scale);

    scale = newScale;
    applyTransform(panOffset.x, panOffset.y, scale);
  }, { passive: false });

  // Touch pinch zoom & pan handlers
  container.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      lastTouchDistance = getDistance(e.touches[0], e.touches[1]);
    } else if (e.touches.length === 1) {
      isPanning = true;
      panStart.x = e.touches[0].clientX - panOffset.x;
      panStart.y = e.touches[0].clientY - panOffset.y;
    }
  }, { passive: false });

  container.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      e.preventDefault();
      const newDistance = getDistance(e.touches[0], e.touches[1]);
      if (lastTouchDistance) {
        let zoomChange = newDistance / lastTouchDistance;
        let newScale = scale * zoomChange;
        newScale = Math.min(Math.max(newScale, 0.2), 5);

        const rect = zoomableContent.getBoundingClientRect();
        const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        const mouseX = midX - rect.left;
        const mouseY = midY - rect.top;

        panOffset.x -= (mouseX / scale) * (newScale - scale);
        panOffset.y -= (mouseY / scale) * (newScale - scale);

        scale = newScale;
        applyTransform(panOffset.x, panOffset.y, scale);
      }
      lastTouchDistance = newDistance;
    } else if (e.touches.length === 1 && isPanning) {
      e.preventDefault();
      panOffset.x = e.touches[0].clientX - panStart.x;
      panOffset.y = e.touches[0].clientY - panStart.y;
      applyTransform(panOffset.x, panOffset.y, scale);
    }
  }, { passive: false });

  container.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) lastTouchDistance = null;
    if (e.touches.length === 0) isPanning = false;
  });

  function getDistance(touch1, touch2) {
    let dx = touch1.clientX - touch2.clientX;
    let dy = touch1.clientY - touch2.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Download composed image at natural size with text boxes rendered
  downloadBtn.addEventListener('click', () => {
    if (!imageElement) return;

    const canvas = document.createElement('canvas');
    canvas.width = imageElement.naturalWidth;
    canvas.height = imageElement.naturalHeight;
    const ctx = canvas.getContext('2d');

    ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);

    const textboxes = zoomableContent.querySelectorAll('.textbox');
    textboxes.forEach(textbox => {
      const style = window.getComputedStyle(textbox);
      const fontSize = parseInt(style.fontSize);
      const fontFamily = style.fontFamily;
      const color = style.color || 'black';
      ctx.fillStyle = color;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.textBaseline = 'top';

      let x = parseFloat(textbox.style.left);
      let y = parseFloat(textbox.style.top);

      const lines = textbox.value.split('\n');
      const lineHeight = fontSize * 1.2;
      lines.forEach((line, i) => {
        ctx.fillText(line, x, y + i * lineHeight);
      });
    });

    const link = document.createElement('a');
    link.download = 'edited-image.png';
    link.href = canvas.toDataURL('image/png');
    link.click();
  });

  // Panning the whole container (desktop)
  container.addEventListener('mousedown', (e) => {
    if (e.target.tagName === 'TEXTAREA') return;
    e.preventDefault();
    isPanning = true;
    panStart.x = e.clientX - panOffset.x;
    panStart.y = e.clientY - panOffset.y;
    container.style.cursor = 'grabbing';
  });

  document.addEventListener('mouseup', () => {
    isPanning = false;
    container.style.cursor = 'grab';
  });

  document.addEventListener('mousemove', (e) => {
    if (!isPanning) return;
    e.preventDefault();
    panOffset.x = e.clientX - panStart.x;
    panOffset.y = e.clientY - panStart.y;
    applyTransform(panOffset.x, panOffset.y, scale);
  });
</script>

<p><small>Note: On desktop, hold <b>Shift</b> and drag the text boxes to move them (to avoid interfering with text input). On mobile, drag text boxes normally.</small></p>

</body>
</html>
