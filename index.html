<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Template Box Editor</title>
<style>
:root {
  --blue: #276ef1;
  --yellow: #ffd600;
  --red: #ea345e;
  --bg: #f3f6fb;
  --text-primary: #20233a;
  --shadow: 0 8px 24px rgba(34,34,68,0.09);
  --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
* {
  box-sizing: border-box;
  -webkit-user-select: none;
  user-select: none;
}
body {
  margin: 20px;
  font-family: var(--font-family);
  background: var(--bg);
  color: var(--text-primary);
  display: flex;
  justify-content: center;
  min-height: 100vh;
}
.container {
  max-width: 980px;
  width: 100%;
  background: white;
  border-radius: 18px;
  box-shadow: var(--shadow);
  padding: 24px 36px 48px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}
h2 {
  margin: 0 0 24px;
  color: var(--blue);
  font-weight: 700;
  letter-spacing: 0.1em;
  text-align: center;
  user-select: none;
}
.controls {
  display: flex;
  flex-wrap: wrap;
  gap: 14px 24px;
  justify-content: center;
  user-select:none;
}
.controls > * {
  min-width: 180px;
  max-width: 280px;
  flex-grow: 1;
  font-size: 1.1em;
  padding: 12px 16px;
  border-radius: 9px;
  border: 1.8px solid #dde4f1;
  background-color: #f7fbff;
  box-shadow: inset 2px 2px 6px #f9fbff, inset -2px -2px 6px #d5dff9;
  transition: all 0.25s ease;
  outline-offset: 3px;
}
.controls > *:focus {
  border-color: var(--blue);
  background-color: white;
  box-shadow: 0 0 10px var(--blue);
  outline: none;
}
button {
  background: var(--blue);
  color: white;
  font-weight: 700;
  cursor: pointer;
  border: none;
  box-shadow: 0 4px 14px #276ef130;
  transition: background-color 0.3s, transform 0.2s ease;
  user-select:none;
}
button:hover,
button:focus {
  background-color: #154ecb;
  transform: translateY(-2px) scale(1.06);
  outline: none;
}
input[type='file'] {
  cursor: pointer;
  padding: 8px 12px;
}
#inputFields {
  max-height: 220px;
  overflow-y: auto;
  background: #e1e8ff;
  box-shadow: inset 1px 1px 6px #bcc9f91c;
  border-radius: 12px;
  padding: 20px 28px;
  display: grid;
  grid-template-columns: repeat(auto-fit,minmax(280px,1fr));
  gap: 18px 30px;
  border: 1.5px solid #cedeff;
  user-select:none;
}
.input-wrapper {
  display: flex;
  flex-direction: column;
  font-weight: 600;
  user-select:none;
}
.input-wrapper label {
  margin-bottom: 8px;
  color: var(--blue);
  font-size: 1.05rem;
  user-select:none;
}
.input-wrapper textarea {
  padding: 8px 12px;
  font-size: 1rem;
  border-radius: 9px;
  border: 1.8px solid #a9b9d6;
  transition: border-color 0.25s ease;
  outline-offset: 3px;
  resize: vertical;
  height: 50px;
  font-family: var(--font-family);
}
.input-wrapper textarea:focus {
  outline: none;
  border-color: var(--blue);
  box-shadow: 0 0 9px var(--blue);
  background: white;
  user-select:text;
}
.font-style-controls {
  margin-top: 6px;
  display: flex;
  gap: 8px;
  user-select:none;
}
.font-style-controls label {
  font-weight: 500;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
}
.font-style-controls input {
  cursor: pointer;
}

#previewContainer {
  position: relative;
  border-radius: 14px;
  border: 3px solid #c0cbed;
  max-width: 100%;
  max-height: 620px;
  overflow: auto;
  background: #f0f4ff;
  box-shadow: inset 0 0 26px #adc6f630;
  align-self: center;
  touch-action: none;
  user-select:none;
}
canvas#templateCanvas {
  display: block;
  border-radius: 12px;
  max-width: 100%;
  max-height: 600px;
  margin: auto;
  background-color: white;
  user-select:none;
}

/* Buttons below inputs */
.buttons-row {
  display: flex;
  justify-content: center;
  gap: 24px;
  flex-wrap: wrap;
  margin-top: 14px;
  user-select:none;
}
.btn-main {
  font-size: 1.17em;
  font-weight: 700;
  border-radius: 12px;
  border: none;
  padding: 16px 38px;
  background: var(--blue);
  color: white;
  cursor: pointer;
  box-shadow: 0 6px 22px #276ef144;
  transition: background-color 0.25s, transform 0.22s ease;
  min-width: 180px;
}
.btn-main:hover,
.btn-main:focus {
  background: #123dbf;
  transform: translateY(-3px) scale(1.05);
  outline: none;
}

/* Responsive */
@media (max-width: 780px) {
  #inputFields {
    grid-template-columns: 1fr;
  }
  .controls {
    flex-direction: column;
  }
  .controls > * {
    max-width: 100%;
  }
}
</style>
</head>
<body>
<div class="container" role="main" aria-label="Template Box Editor">
  <h2>Template Box Editor</h2>

  <div class="controls" role="region" aria-label="Control Panel">
    <input type="file" accept="image/*" id="imageUpload" aria-label="Upload Image" />
    <input type="text" placeholder="New Box Name" id="boxName" aria-label="Box Name Input" autocomplete="off"/>
    <button id="addBoxBtn" aria-label="Add Box Button" title="Add Box">Add Box</button>
    <input type="text" placeholder="Template Name" id="templateName" aria-label="Template Name Input" autocomplete="off"/>
    <button id="saveTemplateBtn" aria-label="Save Template Button" title="Save Template">Save Template</button>
    <button id="loadTemplatesBtn" aria-label="Load Templates Button" title="Load Templates">Load Templates</button>
  </div>

  <div id="inputFields" role="form" aria-label="Box Text Inputs" tabindex="0" ></div>

  <div id="previewContainer" aria-label="Image Preview Panel" tabindex="0">
    <canvas id="templateCanvas"></canvas>
  </div>

  <div class="buttons-row" role="region" aria-label="Action Buttons">
    <button class="btn-main" id="generateTextBtn" aria-label="Generate Text Button" title="Generate Text">Generate Text</button>
    <button class="btn-main" id="downloadBtn" aria-label="Download Image Button" title="Download Image">Download</button>
  </div>

  <div class="template-list" id="templateList" aria-label="Saved Templates List" style="display:none;"></div>
</div>
<script>
(() => {
  const imageUpload = document.getElementById('imageUpload');
  const boxNameInput = document.getElementById('boxName');
  const addBoxBtn = document.getElementById('addBoxBtn');
  const templateNameInput = document.getElementById('templateName');
  const saveTemplateBtn = document.getElementById('saveTemplateBtn');
  const loadTemplatesBtn = document.getElementById('loadTemplatesBtn');
  const inputFields = document.getElementById('inputFields');
  const templateList = document.getElementById('templateList');
  const generateTextBtn = document.getElementById('generateTextBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const canvas = document.getElementById('templateCanvas');
  const ctx = canvas.getContext('2d');

  let image = new Image();
  let boxes = [];

  // Load image and resize canvas
  function loadImage(url) {
    image = new Image();
    image.onload = () => {
      canvas.width = image.width;
      canvas.height = image.height;
      drawCanvas();
      updateInputFields();
      boxes.length && createBoxOverlays();
      showToast('Image loaded');
    };
    image.src = url;
  }

  // Draw image and box text overlays
  function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!image.src) return;
    ctx.drawImage(image, 0, 0);
    boxes.forEach(box => {
      if (!box.text) return;
      ctx.save();
      ctx.translate(box.left + box.width/2, box.top + box.height/2);
      ctx.rotate((box.rotation||0) * Math.PI / 180);
      ctx.textBaseline = 'top';
      ctx.fillStyle = '#222';
      ctx.font = `${box.styles && box.styles.italic ? 'italic ' : ''}${box.styles && box.styles.bold ? 'bold ' : ''}18px "Segoe UI", Arial`;
      ctx.textAlign = box.styles && box.styles.align ? box.styles.align : 'left';
      const lines = box.text.split('\n');
      let y = -box.height/2 + 5;
      let lineHeight = 22;
      lines.forEach(line => {
        let x = -box.width/2 + 6;
        if(box.styles.align === "center") x = 0;
        else if(box.styles.align === "right") x = box.width/2 - 6;
        ctx.fillText(line, x, y, box.width - 12);
        y += lineHeight;
      });
      ctx.restore();
    });
  }

  // Update inputs for every box
  function updateInputFields() {
    inputFields.innerHTML = '';
    if (!boxes.length) {
      inputFields.textContent = 'Add boxes to enter text here.';
      return;
    }
    boxes.forEach(box => {
      const wrapper = document.createElement('div');
      wrapper.className = 'input-wrapper';

      const label = document.createElement('label');
      label.textContent = box.name;
      label.htmlFor = `input-${box.name}`;

      const textarea = document.createElement('textarea');
      textarea.id = `input-${box.name}`;
      textarea.dataset.name = box.name;
      textarea.value = box.text || '';
      textarea.placeholder = `Enter text for "${box.name}"`;
      textarea.addEventListener('input', () => {
        box.text = textarea.value;
        drawCanvas();
      });

      wrapper.appendChild(label);
      wrapper.appendChild(textarea);
      inputFields.appendChild(wrapper);
    });
  }

  // Add box
  function addBox() {
    const name = boxNameInput.value.trim();
    if (!name) {
      showToast('Enter a box name');
      return;
    }
    if (boxes.find(b => b.name.toLowerCase() === name.toLowerCase())) {
      showToast('Box name already exists');
      return;
    }
    if (!image.src) {
      showToast('Please upload image first');
      return;
    }
    boxes.push({
      name,
      left: 70,
      top: 70,
      width: 150,
      height: 50,
      rotation: 0,
      text: '',
      styles: { bold: false, italic: false, align: 'left' }
    });
    boxNameInput.value = '';
    updateInputFields();
    createBoxOverlays();
    drawCanvas();
    showToast(`Box "${name}" added`);
  }

  // Toast helper
  function showToast(msg) {
    if (document.getElementById('toastMessage')) return;
    const toast = document.createElement('div');
    toast.id = 'toastMessage';
    toast.textContent = msg;
    toast.style.cssText =
      'position:fixed;bottom:24px;left:50%;transform:translateX(-50%);background:var(--blue);color:#fff;padding:14px 28px;border-radius:20px;font-weight:600;font-size:1.1em;z-index:10000;opacity:0;transition:opacity 0.3s ease;';
    document.body.appendChild(toast);
    requestAnimationFrame(() => (toast.style.opacity = '1'));
    setTimeout(() => {
      toast.style.opacity = '0';
      setTimeout(() => toast.remove(), 300);
    }, 1800);
  }

  // Create box overlays - Part 2 will include draggable/resizable/rotatable box code.

  // Event bindings
  imageUpload.addEventListener('change', e => {
    let file = imageUpload.files[0];
    if (!file) return;
    let reader = new FileReader();
    reader.onload = evt => loadImage(evt.target.result);
    reader.readAsDataURL(file);
  });
  addBoxBtn.addEventListener('click', addBox);

  window.addEventListener('load', () => {
    // Additional initialization will be posted in Part 2
  });
// --- CONTINUED FROM PART 1 ---
  // Utilities for local templates
  function saveTemplate() {
    const tplName = templateNameInput.value.trim();
    if (!tplName) { showToast("Enter template name"); return; }
    if (!image.src) { showToast("Upload image first"); return; }
    const keys = Object.keys(localStorage).filter(k=>k.startsWith('template_'));
    if (!keys.every(k => k === 'template_' + tplName) && keys.some(k => k.toLowerCase() === ('template_' + tplName).toLowerCase())) {
      showToast("Template name must be unique");
      return;
    }
    boxes.forEach(box => {
      const txtArea = inputFields.querySelector(`textarea[data-name="${box.name}"]`);
      if(txtArea) box.text = txtArea.value;
    });
    localStorage.setItem('template_' + tplName, JSON.stringify({imageSrc: image.src, boxes: boxes}));
    showToast(`Template "${tplName}" saved`);
    loadTemplates();
  }

  function loadTemplates() {
    templateList.style.display = templateList.style.display === "block" ? "none" : "block";
    templateList.innerHTML = "";
    const keys = Object.keys(localStorage).filter(k=>k.startsWith('template_'));
    if (keys.length === 0) {
      templateList.textContent = "No saved templates.";
      return;
    }
    keys.forEach(key => {
      const simpleName = key.substring(9);
      const div = document.createElement('div');
      div.className = "template-item";
      const span = document.createElement('span'); span.textContent = simpleName;
      const loadBtn = document.createElement('button');
      loadBtn.textContent = "Load";
      loadBtn.className = "loadBtn";
      loadBtn.onclick = () => {
        const tpl = JSON.parse(localStorage.getItem(key));
        if(!tpl) { showToast("Error loading template"); return; }
        image.src = tpl.imageSrc;
        image.onload = () => {
          canvas.width = image.width; canvas.height = image.height;
          boxes = (tpl.boxes||[]).map(b => Object.assign({}, b));
          updateInputFields();
          createBoxOverlays();
          drawCanvas();
          templateNameInput.value = simpleName;
        };
        templateList.style.display = "none";
        showToast(`Template "${simpleName}" loaded`);
      };
      const delBtn = document.createElement('button');
      delBtn.textContent = "Delete";
      delBtn.className = "delBtn";
      delBtn.onclick = () => {
        if (confirm(`Delete template "${simpleName}"?`)) {
          localStorage.removeItem(key);
          loadTemplates();
          showToast(`Template "${simpleName}" deleted`);
        }
      };
      div.appendChild(span); div.appendChild(loadBtn); div.appendChild(delBtn);
      templateList.appendChild(div);
    });
  }

  // --- BOX UI INTERACTION ---

  // Remove old overlays and create one for each box — part of live preview UI, not in canvas export
  function createBoxOverlays() {
    // Remove old
    document.querySelectorAll('.box-overlay').forEach(b=>b.remove());
    boxes.forEach(box => {
      const el = document.createElement('div');
      el.className = "box-overlay";
      el.style.position = "absolute";
      el.style.left = `${box.left}px`;
      el.style.top = `${box.top}px`;
      el.style.width = `${box.width}px`;
      el.style.height = `${box.height}px`;
      el.style.border = "2px dashed #ffd600";
      el.style.background = "rgba(255,210,10,0.13)";
      el.style.borderRadius = "12px";
      el.style.zIndex = 8;
      el.style.transform = `rotate(${box.rotation || 0}deg)`;
      el.style.boxSizing = "border-box";
      el.style.touchAction = "none";
      el.dataset.name = box.name;
      el.tabIndex = 0;
      // Title
      el.innerHTML = `<div style="font-size:13px;font-weight:600;color:#333;text-align:center;margin-top:0;">${box.name}</div>`;
      // Drag
      addDragListeners(el, box);
      // Add rotate and resize handle
      addResizeHandles(el, box);
      addRotateHandle(el, box);
      document.getElementById('previewContainer').appendChild(el);
    });
  }

  // Draggable: pointer/mouse/touch events
  function addDragListeners(el, box) {
    let dragging = false, startX, startY, startL, startT;
    el.addEventListener('pointerdown', e => {
      if (e.target.classList.contains('resize-grip') || e.target.classList.contains('rotate-grip')) return;
      dragging = true; startX = e.clientX; startY = e.clientY;
      startL = box.left; startT = box.top;
      el.setPointerCapture(e.pointerId);
      el.style.zIndex = 99;
    });
    el.addEventListener('pointermove', e => {
      if (!dragging) return;
      let dx = e.clientX - startX, dy = e.clientY - startY;
      box.left = Math.round(Math.max(0, Math.min(startL + dx, canvas.width - box.width)));
      box.top = Math.round(Math.max(0, Math.min(startT + dy, canvas.height - box.height)));
      el.style.left = box.left + "px";
      el.style.top = box.top + "px";
      drawCanvas();
    });
    el.addEventListener('pointerup', e => {
      dragging = false; el.style.zIndex = 8;
      drawCanvas();
    });
  }

  // Resizable: bottom-right handle
  function addResizeHandles(el, box) {
    const grip = document.createElement('div');
    grip.className = 'resize-grip';
    Object.assign(grip.style, {
      position:"absolute", right:"-9px", bottom:"-9px", width:"18px", height:"18px",
      background:"#ffd600", borderRadius:"50%", border:"2px solid #fff", cursor:"nwse-resize", zIndex:10
    });
    let resizing = false, startX, startY, origW, origH;
    grip.addEventListener('pointerdown', function(e){
      e.stopPropagation(); resizing=true; startX=e.clientX; startY=e.clientY;
      origW=box.width; origH=box.height; document.body.style.userSelect='none'; grip.setPointerCapture(e.pointerId);
    });
    grip.addEventListener('pointermove', function(e){
      if(!resizing) return;
      let dw = e.clientX - startX, dh = e.clientY - startY;
      box.width = Math.max(40, Math.min(origW + dw, canvas.width - box.left));
      box.height = Math.max(20, Math.min(origH + dh, canvas.height - box.top));
      el.style.width = box.width + "px";
      el.style.height = box.height + "px";
      drawCanvas();
    });
    grip.addEventListener('pointerup', function(){
      resizing = false; document.body.style.userSelect='';
    });
    el.appendChild(grip);
  }

  // Rotatable: top-right handle
  function addRotateHandle(el, box) {
    const grip = document.createElement('div');
    grip.className = 'rotate-grip';
    Object.assign(grip.style, {
      position:"absolute", right:"-9px", top:"-18px", width:"18px", height:"18px",
      background:"#276ef1", borderRadius:"50%", border:"2px solid #fff", cursor:"grab", zIndex:10
    });
    let rotating = false, center={}, startAngle=0, startRot=0;
    grip.addEventListener('pointerdown', function(e){
      e.preventDefault(); e.stopPropagation(); rotating=true;
      center = {x: el.offsetLeft + el.offsetWidth/2, y: el.offsetTop + el.offsetHeight/2 };
      startAngle = Math.atan2(e.clientY - center.y, e.clientX - center.x);
      startRot = box.rotation || 0;
      grip.setPointerCapture(e.pointerId);
    });
    grip.addEventListener('pointermove', function(e){
      if(!rotating) return;
      const theta = Math.atan2(e.clientY - center.y, e.clientX - center.x);
      let deg = startRot + (theta - startAngle)*180/Math.PI;
      box.rotation = Math.round((deg+360)%360);
      el.style.transform = `rotate(${box.rotation}deg)`;
      drawCanvas();
    });
    grip.addEventListener('pointerup', function(){
      rotating = false;
    });
    el.appendChild(grip);
  }

  // Generate text overlays in final output
  function generateText() {
    boxes.forEach(box => {
      const txtArea = inputFields.querySelector(`textarea[data-name="${box.name}"]`);
      if(txtArea) box.text = txtArea.value;
    });
    drawCanvas();
    showToast('Text generated');
  }

  // Export as JPEG
  function download() {
    if (!image.src) { showToast("No canvas to export"); return; }
    canvas.toBlob(function(blob){
      const link = document.createElement("a");
      link.download = "template-output.jpg";
      link.href = URL.createObjectURL(blob);
      link.click();
      URL.revokeObjectURL(link.href);
    }, "image/jpeg", 0.95);
  }

  // Live input font style sync (basic implementation)
  inputFields.addEventListener('change', e => {
    if (!e.target.dataset.name) return;
    const name = e.target.dataset.name;
    const box = boxes.find(b => b.name === name);
    if (!box) return;
    if (e.target.classList.contains('box-bold')) box.styles.bold = e.target.checked;
    if (e.target.classList.contains('box-italic')) box.styles.italic = e.target.checked;
    if (e.target.classList.contains('box-align')) box.styles.align = e.target.value;
    drawCanvas();
  });

  // Undo/Redo
  let undoStack = [], redoStack = [];
  function saveStateForUndo() {
    undoStack.push(JSON.stringify(boxes));
    if (undoStack.length > 20) undoStack.shift();
    redoStack = [];
  }
  function undo() {
    if (undoStack.length < 2) { showToast('Nothing to undo'); return; }
    redoStack.push(undoStack.pop());
    boxes = JSON.parse(undoStack[undoStack.length-1]);
    updateInputFields();
    createBoxOverlays();
    drawCanvas();
    showToast('Undo');
  }
  function redo() {
    if (!redoStack.length) { showToast('Nothing to redo'); return; }
    const state = redoStack.pop();
    undoStack.push(state);
    boxes = JSON.parse(state);
    updateInputFields();
    createBoxOverlays();
    drawCanvas();
    showToast('Redo');
  }
  window.addEventListener('keydown', e => {
    if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); }
    if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); }
  });

  // ----- Initial bindings & helpers -----
  saveTemplateBtn.addEventListener('click', saveTemplate);
  loadTemplatesBtn.addEventListener('click', loadTemplates);
  generateTextBtn.addEventListener('click', generateText);
  downloadBtn.addEventListener('click', download);

  // Create overlays if any boxes present after load
  window.addEventListener('load', () => boxes.length && createBoxOverlays());

  // End of script
})();
</script>
</body>
</html>

